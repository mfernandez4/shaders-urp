using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;


[ExecuteInEditMode]
public class CelestialBody : MonoBehaviour
{
    
    [Range(0, 1024)]
    public int resolution = 100;

    public bool logTimers;

    public CelestialBodySettings bodySettings;
    
    // Private variables
    private Mesh _mesh;
    
    
    private ComputeBuffer _vertexBuffer;

    
    private bool _shapeSettingsUpdated;
    private bool _shadingNoiseSettingsUpdated;

    private Vector2 _heightMinMax;
    
    
    private MeshFilter _terrainMeshFilter;
    private Material _terrainMaterial;

    private static Dictionary<int, SphereMesh> sphereGenerators;


    private void Update()
    {
        if (!Application.isPlaying)
        {
            HandleGeneration();
        }
    }

    // Handles creation of celestial body in the editor
    // This allows for updating the shape/shading settings in the editor
    void HandleGeneration()
    {
        if (!CanGenerateMesh()) return;
        // Debug.Log("HandleGeneration");
        
        // Update shape settings and shading noise
        if (_shapeSettingsUpdated)
        {
            _shapeSettingsUpdated = false;
            _shadingNoiseSettingsUpdated = false;
            // BaseMesh();
            
            var terrainMeshTimer = System.Diagnostics.Stopwatch.StartNew ();
            _heightMinMax = GenerateTerrainMesh(ref _mesh, resolution);
            
            if (logTimers) Debug.Log("Terrain mesh generation: " + terrainMeshTimer.ElapsedMilliseconds + "ms");
            
            DrawMesh();
        }
        
        // If only shading noise has changed, update it separately from shape to save time
        else if (_shadingNoiseSettingsUpdated)
        {
            _shadingNoiseSettingsUpdated = false;
            
            // TODO: Dispatch shading compute shader from CelestialBodyShading ( GenereateShadingData )
            Debug.Log("Shading noise settings updated");
        }
    }

    private void BaseMesh()
    {
        Debug.Log("BaseMesh");
        Vector3[] vertices = new Vector3[] { Vector3.zero };
        
        // Create vertex buffer
        int stride = System.Runtime.InteropServices.Marshal.SizeOf(typeof(Vector3));
        _vertexBuffer = new ComputeBuffer(vertices.Length, stride);
        _vertexBuffer.SetData(vertices);
        
        bodySettings.shape.CalculateHeights(_vertexBuffer);
    }


    public void OnShapeSettingChanged()
    {
        _shapeSettingsUpdated = true;
    }
    
    public void OnShadingSettingChanged()
    {
        _shadingNoiseSettingsUpdated = true;
    }


    private void OnValidate()
    {
        if (bodySettings)
        {
            if (bodySettings.shape)
            {
                bodySettings.shape.OnSettingChanged -= OnShapeSettingChanged;
                bodySettings.shape.OnSettingChanged += OnShapeSettingChanged;
            }
            
            if (bodySettings.shading)
            {
                bodySettings.shading.OnSettingChanged -= OnShadingSettingChanged;
                bodySettings.shading.OnSettingChanged += OnShadingSettingChanged;
            }
        }
        
        OnShapeSettingChanged();
    }


    // Generates terrain mesh based on heights generated by the Shape object
    // Shading data from the Shading object is stored in the mesh uvs
    // Returns the min/max height of the terrain
    private Vector2 GenerateTerrainMesh(ref Mesh mesh, int res)
    {
        Debug.Log("GenerateTerrainMesh ...");
        var (vertices, triangles) = CreateSphereVertsAndTris (res);
        
        // Create vertex buffer
        int stride = System.Runtime.InteropServices.Marshal.SizeOf(typeof(Vector3));
        _vertexBuffer = new ComputeBuffer(vertices.Length, stride);
        _vertexBuffer.SetData(vertices);
        
        // Calculate edge length
        float edgeLength = (vertices[triangles[0]] - vertices[triangles[1]]).magnitude;
        
        // set heights
        float[] heights = bodySettings.shape.CalculateHeights(_vertexBuffer);
        
        // TODO: Perturb vertices to give terrain a less perfectly smooth appearance
        
        
        // Calculate terrain min/max heights and set heights of the vertices
        float minHeight = float.MaxValue; // Or we can use float.PositiveInfinity
        float maxHeight = float.MinValue; // Or we can use float.NegativeInfinity
        
        // Loop through the heights
        for (int i = 0; i < heights.Length; i++)
        {
            float height = heights[i];
            vertices[i] *= height; // Apply height to the vertex
            minHeight = Mathf.Min(minHeight, height);
            maxHeight = Mathf.Max(maxHeight, height);
        }
        
        // Create mesh
        CreateMesh(ref mesh, vertices.Length);
        _mesh.SetVertices(vertices);
        _mesh.SetTriangles(triangles, 0, true);
        _mesh.RecalculateNormals();
        
        // TODO: Shading noise data
        
        
        // Create crude tangent data (vectors perpendicular to the surface normal)
        var normals = _mesh.normals;
        var crudeTangents = new Vector4[normals.Length];
        for (int i = 0; i < normals.Length; i++)
        {
            var normal = normals[i];
            // Calculate the tangent -- the vector perpendicular to the normal
            crudeTangents[i] = new Vector4(-normal.z, 0, normal.x, 1);
        }
        _mesh.SetTangents(crudeTangents);
        
        // Return the min/max height
        return new Vector2(minHeight, maxHeight);
    }

    
    private void CreateMesh(ref Mesh mesh, int numVertices)
    {
        // Vertex count check - 16 bit index buffer limit is 65535. If the vertex count exceeds this, we need to use 32 bit index buffer.
        const int vertexLimit16Bit = 1 << 16 - 1; // 65535
        
        if (mesh == null) mesh = new Mesh();
        else mesh.Clear();
        
        // Set the mesh index format - 16 bit or 32 bit
        mesh.indexFormat = numVertices > vertexLimit16Bit ? UnityEngine.Rendering.IndexFormat.UInt32 : UnityEngine.Rendering.IndexFormat.UInt16;
    }


    private void DrawMesh()
    {
        GameObject terrainObject = GetOrCreateMeshObject ("Terrain Mesh", _mesh, bodySettings.shading.terrainMaterial);
    }

    private GameObject GetOrCreateMeshObject(string name, Mesh mesh, Material terrainMaterial)
    {
        // Find or Create the terrain object
        var child = transform.Find(name); // Find the child object

        if (!child)
        {
            child = new GameObject(name).transform; // Create a new child object
            child.SetParent(transform); // Set the parent
            child.localPosition = Vector3.zero; // Set the position
            child.localRotation = Quaternion.identity; // Set the rotation
            child.localScale = Vector3.one; // Set the scale
            child.gameObject.layer = gameObject.layer; // Set the layer
        }
        
        // Add mesh components
        MeshFilter meshFilter;
        
        // if the child has a mesh filter, get it. Otherwise, add a mesh filter
        if (!child.TryGetComponent<MeshFilter>(out meshFilter)) meshFilter = child.gameObject.AddComponent<MeshFilter>();
        meshFilter.sharedMesh = mesh;
        
        MeshRenderer meshRenderer;
        
        // if the child has a mesh renderer, get it. Otherwise, add a mesh renderer
        if (!child.TryGetComponent<MeshRenderer>(out meshRenderer)) meshRenderer = child.gameObject.AddComponent<MeshRenderer>();
        meshRenderer.sharedMaterial = terrainMaterial;
        
        
        return child.gameObject;
    }


    private (Vector3[] vertices, int[] triangles) CreateSphereVertsAndTris(int res)
    {
        // Create sphere mesh generator
        if (sphereGenerators == null) sphereGenerators = new Dictionary<int, SphereMesh>();
        
        if (!sphereGenerators.ContainsKey(res)) sphereGenerators.Add(res, new SphereMesh(res));
        
        var generator = sphereGenerators[res];
        
        // Create vertices and triangles
        var vertices = new Vector3[generator.Vertices.Length];
        var triangles = new int[generator.Triangles.Length];
        System.Array.Copy(generator.Vertices, vertices, vertices.Length);
        System.Array.Copy(generator.Triangles, triangles, triangles.Length);
        return (vertices, triangles);
    }

    
    private bool CanGenerateMesh()
    {
        return bodySettings.shape && bodySettings.shape.heightMapCompute;
    }


    private void OnDestroy()
    {
        ReleaseAllBuffers();
    }

    private void ReleaseAllBuffers()
    {
        _vertexBuffer?.Release();
        bodySettings.shape.ReleaseBuffers();
    }



    public class TerrainData
    {
        public float[] heights;
        public Vector4[] uvs;
    }
}
